<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Enhanced 3D Tactical Shooter</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: Arial, sans-serif;
            background: #0a0a0a;
            color: #ffffff;
            overflow: hidden;
        }
        
        #gameContainer {
            position: relative;
            width: 100vw;
            height: 100vh;
        }
        
        #loadingScreen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, #1a1a2e, #16213e);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }
        
        #loadingScreen h2 {
            font-size: 3rem;
            margin-bottom: 1rem;
            text-shadow: 0 0 10px #00ffff;
            letter-spacing: 3px;
        }
        
        #startButton {
            padding: 15px 30px;
            font-size: 1.1rem;
            background: linear-gradient(45deg, #ff6b6b, #ee5a52);
            border: none;
            border-radius: 5px;
            color: white;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        
        #startButton:hover {
            background: linear-gradient(45deg, #ee5a52, #ff6b6b);
            transform: translateY(-2px);
        }
        
        #gameCanvas {
            display: none;
            width: 100%;
            height: 100%;
        }
        
        #gameUI {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 100;
            display: none;
        }
        
        #crosshair {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 20px;
            height: 20px;
            pointer-events: none;
        }
        
        #crosshair::before,
        #crosshair::after {
            content: '';
            position: absolute;
            background: #00ffff;
            box-shadow: 0 0 5px #00ffff;
        }
        
        #crosshair::before {
            top: 50%;
            left: 45%;
            width: 10%;
            height: 2px;
            transform: translateY(-50%);
        }
        
        #crosshair::after {
            top: 45%;
            left: 50%;
            width: 2px;
            height: 10%;
            transform: translateX(-50%);
        }
        
        #stats {
            position: absolute;
            top: 20px;
            left: 20px;
            font-family: monospace;
            font-size: 14px;
            line-height: 1.5;
            background: rgba(0, 0, 0, 0.7);
            padding: 15px;
            border-radius: 5px;
            border: 1px solid #333;
        }
        
        .stat-bar {
            width: 150px;
            height: 8px;
            background: #333;
            border-radius: 4px;
            overflow: hidden;
            margin: 5px 0;
        }
        
        .stat-fill {
            height: 100%;
            transition: width 0.3s ease;
        }
        
        .health-fill { background: linear-gradient(90deg, #ff4444, #ff6666); }
        .ammo-fill { background: linear-gradient(90deg, #4444ff, #6666ff); }
        .armor-fill { background: linear-gradient(90deg, #ffaa00, #ffcc44); }
        
        #damageOverlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: radial-gradient(circle, transparent 30%, rgba(255, 0, 0, 0.3) 100%);
            opacity: 0;
            transition: opacity 0.2s ease;
            pointer-events: none;
        }
        
        #instructions {
            position: absolute;
            bottom: 20px;
            left: 20px;
            font-size: 12px;
            background: rgba(0, 0, 0, 0.7);
            padding: 10px;
            border-radius: 5px;
            line-height: 1.4;
        }
        
        .kill-notification {
            position: absolute;
            top: 30%;
            right: 30px;
            background: rgba(255, 0, 0, 0.8);
            color: white;
            padding: 10px 20px;
            border-radius: 5px;
            font-weight: bold;
            animation: killFade 2s ease-out forwards;
        }
        
        @keyframes killFade {
            0% { opacity: 1; transform: translateX(0); }
            100% { opacity: 0; transform: translateX(100px); }
        }
        
        #pauseMenu {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.9);
            z-index: 1000;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            backdrop-filter: blur(5px);
        }
        
        #pauseMenu h2 {
            font-size: 3rem;
            margin-bottom: 1rem;
            text-shadow: 0 0 20px #00ffff;
            animation: pulse 2s ease-in-out infinite alternate;
        }
        
        @keyframes pulse {
            from { text-shadow: 0 0 10px #00ffff; }
            to { text-shadow: 0 0 30px #00ffff, 0 0 40px #00ffff; }
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <div id="loadingScreen">
            <h2>üéÆ 3D Tactical Shooter</h2>
            <p style="margin-bottom: 2rem;">Enhanced Edition - Immersive Combat Experience</p>
            <button id="startButton">START GAME</button>
        </div>
        
        <canvas id="gameCanvas"></canvas>
        
        <div id="gameUI">
            <div id="crosshair"></div>
            
            <div id="stats">
                <div>Health: <span id="healthText">300</span></div>
                <div class="stat-bar"><div class="stat-fill health-fill" id="healthBar" style="width: 100%"></div></div>
                
                <div>Armor: <span id="armorText">100</span></div>
                <div class="stat-bar"><div class="stat-fill armor-fill" id="armorBar" style="width: 100%"></div></div>
                
                <div>Ammo: <span id="ammoText">30/120</span></div>
                <div class="stat-bar"><div class="stat-fill ammo-fill" id="ammoBar" style="width: 100%"></div></div>
                
                <div>Kills: <span id="killsText">0</span></div>
                <div>Wave: <span id="waveText">1</span></div>
                <div>Time: <span id="timeText">0:00</span></div>
                <div>Position: <span id="positionText">(0, 0)</span></div>
                <div style="color: #ffaa00; font-size: 12px;">Enemy Bullets: <span id="bulletCount">0</span></div>
            </div>
            
            <div id="instructions">
                WASD: Move | Mouse: Look | Left Click: Shoot<br>
                R: Reload | ESC: Pause | Eliminate all enemies!<br>
                <span style="color: #ffff00;">Yellow bullets: Player</span> | 
                <span style="color: #ff4444;">Red bullets: Enemies</span><br>
                <span style="color: #00ff00;">üó∫Ô∏è Expanded Map: 200√ó200 units - Explore freely!</span>
            </div>
            
            <div id="damageOverlay"></div>
            
            <!-- Pause Menu -->
            <div id="pauseMenu" style="display: none;">
                <div style="text-align: center; color: white; font-family: Arial, sans-serif;">
                    <h2>‚è∏Ô∏è GAME PAUSED</h2>
                    <p style="font-size: 1.2rem; margin-bottom: 2rem; opacity: 0.8;">Press ESC to resume or switch tabs freely</p>
                    <div style="background: rgba(255, 255, 255, 0.1); padding: 20px; border-radius: 10px; border: 1px solid #333;">
                        <p style="margin: 5px 0;"><strong>Wave:</strong> <span id="pauseWave">1</span></p>
                        <p style="margin: 5px 0;"><strong>Kills:</strong> <span id="pauseKills">0</span></p>
                        <p style="margin: 5px 0;"><strong>Time:</strong> <span id="pauseTime">0:00</span></p>
                        <p style="margin: 5px 0;"><strong>Health:</strong> <span id="pauseHealth">300</span></p>
                        <p style="margin: 5px 0;"><strong>Armor:</strong> <span id="pauseArmor">100</span></p>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        console.log('üéÆ Enhanced Tactical Shooter initializing...');
        
        // Simple Audio System
        class SimpleAudio {
            constructor() {
                this.audioContext = null;
                this.isEnabled = true;
                this.init();
            }
            
            init() {
                try {
                    this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
                    console.log('‚úÖ Audio system ready');
                } catch (error) {
                    console.warn('‚ö†Ô∏è Audio not available:', error);
                    this.isEnabled = false;
                }
            }
            
            playShoot() {
                if (!this.isEnabled || !this.audioContext) return;
                
                const oscillator = this.audioContext.createOscillator();
                const gainNode = this.audioContext.createGain();
                
                oscillator.type = 'square';
                oscillator.frequency.setValueAtTime(300, this.audioContext.currentTime);
                oscillator.frequency.exponentialRampToValueAtTime(50, this.audioContext.currentTime + 0.1);
                
                gainNode.gain.setValueAtTime(0.3, this.audioContext.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(0.001, this.audioContext.currentTime + 0.15);
                
                oscillator.connect(gainNode);
                gainNode.connect(this.audioContext.destination);
                
                oscillator.start(this.audioContext.currentTime);
                oscillator.stop(this.audioContext.currentTime + 0.15);
            }
            
            playHit() {
                if (!this.isEnabled || !this.audioContext) return;
                
                const oscillator = this.audioContext.createOscillator();
                const gainNode = this.audioContext.createGain();
                
                oscillator.type = 'sawtooth';
                oscillator.frequency.setValueAtTime(150, this.audioContext.currentTime);
                oscillator.frequency.exponentialRampToValueAtTime(80, this.audioContext.currentTime + 0.2);
                
                gainNode.gain.setValueAtTime(0.25, this.audioContext.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(0.001, this.audioContext.currentTime + 0.3);
                
                oscillator.connect(gainNode);
                gainNode.connect(this.audioContext.destination);
                
                oscillator.start();
                oscillator.stop(this.audioContext.currentTime + 0.3);
            }
            
            playPlayerHurt() {
                if (!this.isEnabled || !this.audioContext) return;
                
                const oscillator = this.audioContext.createOscillator();
                const gainNode = this.audioContext.createGain();
                
                oscillator.type = 'sine';
                oscillator.frequency.setValueAtTime(800, this.audioContext.currentTime);
                oscillator.frequency.exponentialRampToValueAtTime(200, this.audioContext.currentTime + 0.4);
                
                gainNode.gain.setValueAtTime(0.4, this.audioContext.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(0.001, this.audioContext.currentTime + 0.4);
                
                oscillator.connect(gainNode);
                gainNode.connect(this.audioContext.destination);
                
                oscillator.start();
                oscillator.stop(this.audioContext.currentTime + 0.4);
            }
            
            playEnemyShoot() {
                if (!this.isEnabled || !this.audioContext) return;
                
                const oscillator = this.audioContext.createOscillator();
                const gainNode = this.audioContext.createGain();
                
                oscillator.type = 'triangle';
                oscillator.frequency.setValueAtTime(250, this.audioContext.currentTime);
                oscillator.frequency.exponentialRampToValueAtTime(40, this.audioContext.currentTime + 0.12);
                
                gainNode.gain.setValueAtTime(0.2, this.audioContext.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(0.001, this.audioContext.currentTime + 0.12);
                
                oscillator.connect(gainNode);
                gainNode.connect(this.audioContext.destination);
                
                oscillator.start(this.audioContext.currentTime);
                oscillator.stop(this.audioContext.currentTime + 0.12);
            }
        }

        class EnhancedTacticalShooter {
            constructor() {
                this.scene = null;
                this.camera = null;
                this.renderer = null;
                this.clock = new THREE.Clock();
                this.audio = new SimpleAudio();
                
                // Game state
                this.isRunning = false;
                this.isPaused = false;
                this.isPointerLocked = false;
                this.startTime = null;
                this.currentWave = 1;
                this.enemiesKilledThisWave = 0;
                this.enemiesPerWave = 4; // Start with more enemies for excitement
                
                // Player state
                this.player = {
                    position: new THREE.Vector3(0, 1.8, 0),
                    rotation: { x: 0, y: 0 },
                    health: 300,
                    maxHealth: 300,
                    ammo: 30,
                    maxAmmo: 30,
                    totalAmmo: 120,
                    kills: 0,
                    speed: 8,
                    armor: 100,
                    maxArmor: 100,
                    lastHealthRegen: 0,
                    lastArmorRegen: 0, // Separate timer for armor regeneration
                    healthRegenRate: 8000 // Regen health every 8 seconds
                };
                
                // Controls state
                this.keys = {};
                this.lastShotTime = 0;
                this.shotCooldown = 150;
                
                // Enemy system
                this.enemies = [];
                this.maxEnemies = this.enemiesPerWave;
                this.lastSpawnTime = 0;
                this.spawnDelay = 2500; // Faster spawn for more action (2.5 seconds)
                
                // Health pack system
                this.healthPacks = [];
                this.lastHealthPackSpawn = 0;
                this.healthPackSpawnRate = 20000; // Spawn health pack every 20 seconds
                
                // Bullet system
                this.enemyBullets = [];
                this.playerBullets = [];
                
                // Physics system
                this.raycaster = new THREE.Raycaster();
                this.walls = [];
                
                this.init();
            }
            
            init() {
                console.log('Initializing Three.js...');
                this.setupThreeJS();
                console.log('Setting up controls...');
                this.setupControls();
                console.log('Setting up UI...');
                this.setupUI();
                console.log('Creating world...');
                this.createWorld();
                console.log('‚úÖ Game initialized');
            }
            
            setupThreeJS() {
                // Scene
                this.scene = new THREE.Scene();
                this.scene.background = new THREE.Color(0x001122);
                this.scene.fog = new THREE.Fog(0x001122, 50, 180);  // Increased fog distance for larger map
                
                // Camera
                this.camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
                this.camera.position.copy(this.player.position);
                
                // Renderer
                this.renderer = new THREE.WebGLRenderer({ 
                    canvas: document.getElementById('gameCanvas'),
                    antialias: true 
                });
                this.renderer.setSize(window.innerWidth, window.innerHeight);
                this.renderer.shadowMap.enabled = true;
                this.renderer.shadowMap.type = THREE.PCFSoftShadowMap;
                
                // Lighting system
                const ambientLight = new THREE.AmbientLight(0x404080, 0.4);
                this.scene.add(ambientLight);
                
                // Main light
                const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
                directionalLight.position.set(30, 40, 30);
                directionalLight.castShadow = true;
                directionalLight.shadow.mapSize.width = 2048;
                directionalLight.shadow.mapSize.height = 2048;
                directionalLight.shadow.camera.near = 0.1;
                directionalLight.shadow.camera.far = 200;  // Increased for larger map
                directionalLight.shadow.camera.left = -100;   // Expanded shadow coverage
                directionalLight.shadow.camera.right = 100;
                directionalLight.shadow.camera.top = 100;
                directionalLight.shadow.camera.bottom = -100;
                this.scene.add(directionalLight);
            }
            
            setupControls() {
                // Keyboard events
                document.addEventListener('keydown', (e) => {
                    this.keys[e.code] = true;
                    if (e.code === 'KeyR') this.reload();
                    if (e.code === 'Escape') this.togglePause();
                });
                
                document.addEventListener('keyup', (e) => {
                    this.keys[e.code] = false;
                });
                
                // Mouse events
                document.addEventListener('mousemove', (e) => {
                    if (this.isPointerLocked && !this.isPaused) {
                        this.player.rotation.y -= e.movementX * 0.002;
                        this.player.rotation.x -= e.movementY * 0.002;
                        this.player.rotation.x = Math.max(-Math.PI/3, Math.min(Math.PI/3, this.player.rotation.x));
                    }
                });
                
                document.addEventListener('click', (e) => {
                    if (this.isPointerLocked && e.button === 0 && !this.isPaused) {
                        this.shoot();
                    } else if (!this.isPointerLocked && this.isRunning && !this.isPaused) {
                        // If pointer lock is lost, try to re-acquire it
                        console.log('üîÑ Attempting to re-acquire pointer lock...');
                        document.body.requestPointerLock().catch((error) => {
                            console.warn('‚ö†Ô∏è Failed to re-acquire pointer lock:', error);
                        });
                    }
                });
                
                // Pointer lock
                document.addEventListener('pointerlockchange', () => {
                    const wasLocked = this.isPointerLocked;
                    this.isPointerLocked = document.pointerLockElement === document.body;
                    
                    if (wasLocked !== this.isPointerLocked) {
                        if (this.isPointerLocked) {
                            console.log('üîí Pointer lock acquired - Mouse control enabled');
                        } else {
                            console.log('üîì Pointer lock lost - Mouse control disabled');
                        }
                    }
                });
                
                // Window resize
                window.addEventListener('resize', () => {
                    this.camera.aspect = window.innerWidth / window.innerHeight;
                    this.camera.updateProjectionMatrix();
                    this.renderer.setSize(window.innerWidth, window.innerHeight);
                });
                
                // Page visibility detection for auto-pause
                document.addEventListener('visibilitychange', () => {
                    if (this.isRunning) {
                        if (document.hidden) {
                            // Page is hidden (user switched tabs), auto-pause
                            if (!this.isPaused) {
                                this.togglePause();
                                console.log('üîÑ Auto-paused: Tab switched');
                            }
                        } else {
                            // Page is visible again, but keep paused for user choice
                            console.log('üëÅÔ∏è Tab returned: Game remains paused (press ESC to resume)');
                        }
                    }
                });
                
                // Window focus/blur events as backup
                window.addEventListener('blur', () => {
                    if (this.isRunning && !this.isPaused) {
                        this.togglePause();
                        console.log('üîÑ Auto-paused: Window lost focus');
                    }
                });
            }
            
            setupUI() {
                const startButton = document.getElementById('startButton');
                startButton.addEventListener('click', (e) => {
                    e.preventDefault();
                    console.log('Start button clicked');
                    this.start();
                });
            }
            
            createWorld() {
                // Ground
                this.createGround();
                
                // Buildings and environment
                this.createBuildings();
                this.createWalls();
                this.createObstacles();
            }
            
            createGround() {
                // Main ground - expanded to 400x400 for larger play area
                const groundGeometry = new THREE.PlaneGeometry(400, 400);
                const groundMaterial = new THREE.MeshLambertMaterial({ color: 0x2a2a2a });
                const ground = new THREE.Mesh(groundGeometry, groundMaterial);
                ground.rotation.x = -Math.PI / 2;
                ground.receiveShadow = true;
                this.scene.add(ground);
            }
            
            createBuildings() {
                // Create more buildings spread across larger area
                const buildings = [
                    // Corner buildings - further out
                    { x: 60, z: 60, w: 8, h: 12, d: 8, color: 0x666666 },
                    { x: -60, z: 60, w: 6, h: 8, d: 10, color: 0x555555 },
                    { x: 60, z: -60, w: 10, h: 15, d: 6, color: 0x777777 },
                    { x: -60, z: -60, w: 12, h: 10, d: 12, color: 0x606060 },
                    
                    // Mid-range buildings
                    { x: 40, z: 0, w: 7, h: 9, d: 9, color: 0x6a6a6a },
                    { x: -40, z: 0, w: 9, h: 11, d: 7, color: 0x585858 },
                    { x: 0, z: 40, w: 8, h: 13, d: 8, color: 0x707070 },
                    { x: 0, z: -40, w: 6, h: 7, d: 11, color: 0x626262 },
                    
                    // Additional scattered buildings
                    { x: 25, z: 35, w: 5, h: 8, d: 5, color: 0x646464 },
                    { x: -25, z: 35, w: 7, h: 10, d: 6, color: 0x686868 },
                    { x: 25, z: -35, w: 6, h: 9, d: 7, color: 0x5c5c5c },
                    { x: -25, z: -35, w: 8, h: 6, d: 8, color: 0x747474 },
                    
                    // Far perimeter buildings
                    { x: 80, z: 30, w: 6, h: 14, d: 6, color: 0x565656 },
                    { x: -80, z: 30, w: 8, h: 12, d: 7, color: 0x6c6c6c },
                    { x: 80, z: -30, w: 7, h: 11, d: 8, color: 0x5a5a5a },
                    { x: -80, z: -30, w: 9, h: 9, d: 6, color: 0x6e6e6e },
                    
                    { x: 30, z: 80, w: 5, h: 7, d: 9, color: 0x545454 },
                    { x: -30, z: 80, w: 10, h: 13, d: 5, color: 0x727272 },
                    { x: 30, z: -80, w: 8, h: 10, d: 7, color: 0x585858 },
                    { x: -30, z: -80, w: 6, h: 8, d: 10, color: 0x6a6a6a }
                ];
                
                buildings.forEach(building => {
                    const geometry = new THREE.BoxGeometry(building.w, building.h, building.d);
                    const material = new THREE.MeshLambertMaterial({ color: building.color });
                    const mesh = new THREE.Mesh(geometry, material);
                    mesh.position.set(building.x, building.h/2, building.z);
                    mesh.castShadow = true;
                    mesh.receiveShadow = true;
                    this.scene.add(mesh);
                    this.walls.push(mesh);
                });
            }
            
            createWalls() {
                // Expanded perimeter walls - doubled the play area
                const wallHeight = 8;
                const wallPositions = [
                    { x: 0, z: 100, w: 200, h: wallHeight, d: 2 },   // North wall
                    { x: 0, z: -100, w: 200, h: wallHeight, d: 2 },  // South wall
                    { x: 100, z: 0, w: 2, h: wallHeight, d: 200 },   // East wall
                    { x: -100, z: 0, w: 2, h: wallHeight, d: 200 }   // West wall
                ];
                
                wallPositions.forEach(pos => {
                    const geometry = new THREE.BoxGeometry(pos.w, pos.h, pos.d);
                    const material = new THREE.MeshLambertMaterial({ color: 0x888888 });
                    const wall = new THREE.Mesh(geometry, material);
                    wall.position.set(pos.x, pos.h/2, pos.z);
                    wall.castShadow = true;
                    wall.receiveShadow = true;
                    this.scene.add(wall);
                    this.walls.push(wall);
                });
            }
            
            createObstacles() {
                // Various obstacles and cover spread across larger area
                const obstacles = [
                    // Inner ring obstacles
                    { type: 'box', x: 15, z: 15, size: 1.5, color: 0x8B4513 },
                    { type: 'box', x: -15, z: 15, size: 1.5, color: 0x8B4513 },
                    { type: 'box', x: 15, z: -15, size: 1.5, color: 0x8B4513 },
                    { type: 'box', x: -15, z: -15, size: 1.5, color: 0x8B4513 },
                    
                    // Mid ring obstacles
                    { type: 'box', x: 35, z: 20, size: 1.8, color: 0x654321 },
                    { type: 'box', x: -35, z: 20, size: 1.8, color: 0x654321 },
                    { type: 'box', x: 35, z: -20, size: 1.8, color: 0x654321 },
                    { type: 'box', x: -35, z: -20, size: 1.8, color: 0x654321 },
                    { type: 'box', x: 20, z: 35, size: 1.8, color: 0x654321 },
                    { type: 'box', x: -20, z: 35, size: 1.8, color: 0x654321 },
                    { type: 'box', x: 20, z: -35, size: 1.8, color: 0x654321 },
                    { type: 'box', x: -20, z: -35, size: 1.8, color: 0x654321 },
                    
                    // Outer ring obstacles
                    { type: 'box', x: 55, z: 10, size: 2.0, color: 0x5d4e37 },
                    { type: 'box', x: -55, z: 10, size: 2.0, color: 0x5d4e37 },
                    { type: 'box', x: 55, z: -10, size: 2.0, color: 0x5d4e37 },
                    { type: 'box', x: -55, z: -10, size: 2.0, color: 0x5d4e37 },
                    { type: 'box', x: 10, z: 55, size: 2.0, color: 0x5d4e37 },
                    { type: 'box', x: -10, z: 55, size: 2.0, color: 0x5d4e37 },
                    { type: 'box', x: 10, z: -55, size: 2.0, color: 0x5d4e37 },
                    { type: 'box', x: -10, z: -55, size: 2.0, color: 0x5d4e37 },
                    
                    // Far perimeter obstacles
                    { type: 'box', x: 75, z: 45, size: 1.6, color: 0x8B4513 },
                    { type: 'box', x: -75, z: 45, size: 1.6, color: 0x8B4513 },
                    { type: 'box', x: 75, z: -45, size: 1.6, color: 0x8B4513 },
                    { type: 'box', x: -75, z: -45, size: 1.6, color: 0x8B4513 },
                    { type: 'box', x: 45, z: 75, size: 1.6, color: 0x8B4513 },
                    { type: 'box', x: -45, z: 75, size: 1.6, color: 0x8B4513 },
                    { type: 'box', x: 45, z: -75, size: 1.6, color: 0x8B4513 },
                    { type: 'box', x: -45, z: -75, size: 1.6, color: 0x8B4513 },
                    
                    // Additional scattered cover
                    { type: 'box', x: 0, z: 25, size: 1.2, color: 0x654321 },
                    { type: 'box', x: 0, z: -25, size: 1.2, color: 0x654321 },
                    { type: 'box', x: 25, z: 0, size: 1.2, color: 0x654321 },
                    { type: 'box', x: -25, z: 0, size: 1.2, color: 0x654321 }
                ];
                
                obstacles.forEach(obs => {
                    const geometry = new THREE.BoxGeometry(obs.size, obs.size * 2, obs.size);
                    const material = new THREE.MeshLambertMaterial({ color: obs.color });
                    const obstacle = new THREE.Mesh(geometry, material);
                    obstacle.position.set(obs.x, obs.size, obs.z);
                    obstacle.castShadow = true;
                    obstacle.receiveShadow = true;
                    this.scene.add(obstacle);
                    this.walls.push(obstacle);
                });
            }
            
            createHumanoidEnemy(position) {
                const group = new THREE.Group();
                
                // Torso
                const torsoGeometry = new THREE.BoxGeometry(0.8, 1.2, 0.4);
                const torsoMaterial = new THREE.MeshLambertMaterial({ color: 0x2d2d2d });
                const torso = new THREE.Mesh(torsoGeometry, torsoMaterial);
                torso.position.y = 1.2;
                group.add(torso);
                
                // Head
                const headGeometry = new THREE.SphereGeometry(0.3);
                const headMaterial = new THREE.MeshLambertMaterial({ color: 0xFFDBB3 });
                const head = new THREE.Mesh(headGeometry, headMaterial);
                head.position.y = 2.1;
                group.add(head);
                
                // Eyes (glowing red)
                const eyeGeometry = new THREE.SphereGeometry(0.05);
                const eyeMaterial = new THREE.MeshBasicMaterial({ color: 0xff0000 });
                const leftEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
                leftEye.position.set(-0.1, 2.15, 0.25);
                const rightEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
                rightEye.position.set(0.1, 2.15, 0.25);
                group.add(leftEye);
                group.add(rightEye);
                
                // Arms
                const armGeometry = new THREE.BoxGeometry(0.2, 0.8, 0.2);
                const armMaterial = new THREE.MeshLambertMaterial({ color: 0xFFDBB3 });
                
                const leftArm = new THREE.Mesh(armGeometry, armMaterial);
                leftArm.position.set(-0.6, 1.2, 0);
                const rightArm = new THREE.Mesh(armGeometry, armMaterial);
                rightArm.position.set(0.6, 1.2, 0);
                group.add(leftArm);
                group.add(rightArm);
                
                // Legs
                const legGeometry = new THREE.BoxGeometry(0.25, 0.8, 0.25);
                const legMaterial = new THREE.MeshLambertMaterial({ color: 0x1a1a1a });
                
                const leftLeg = new THREE.Mesh(legGeometry, legMaterial);
                leftLeg.position.set(-0.25, 0.4, 0);
                const rightLeg = new THREE.Mesh(legGeometry, legMaterial);
                rightLeg.position.set(0.25, 0.4, 0);
                group.add(leftLeg);
                group.add(rightLeg);
                
                group.position.copy(position);
                group.castShadow = true;
                
                // Enable shadows for each part
                group.traverse((child) => {
                    if (child instanceof THREE.Mesh) {
                        child.castShadow = true;
                        child.receiveShadow = true;
                    }
                });
                
                this.scene.add(group);
                
                const enemy = {
                    mesh: group,
                    position: position.clone(),
                    health: 100,
                    maxHealth: 100,
                    target: this.player.position,
                    lastAttackTime: 0,
                    speed: 4.5, // Increased from 3 to 4.5 for faster movement
                    attackRange: 10, // Increased from 8 to 10 for longer range
                    isAlive: true,
                    walkAnimation: 0,
                    lastDamageTime: 0,
                    // Store body part references for animation
                    parts: {
                        leftArm: leftArm,
                        rightArm: rightArm,
                        leftLeg: leftLeg,
                        rightLeg: rightLeg,
                        head: head,
                        torso: torso
                    }
                };
                
                this.enemies.push(enemy);
                return enemy;
            }
            
            spawnEnemies() {
                const now = Date.now();
                const aliveEnemies = this.enemies.filter(e => e.isAlive).length;
                
                if (aliveEnemies < this.maxEnemies && now - this.lastSpawnTime > this.spawnDelay) {
                    // Expanded spawn points for larger map (¬±80 range instead of ¬±40)
                    const spawnPoints = [
                        new THREE.Vector3(80, 0, 80),
                        new THREE.Vector3(-80, 0, 80),
                        new THREE.Vector3(80, 0, -80),
                        new THREE.Vector3(-80, 0, -80),
                        new THREE.Vector3(70, 0, 0),
                        new THREE.Vector3(-70, 0, 0),
                        new THREE.Vector3(0, 0, 70),
                        new THREE.Vector3(0, 0, -70),
                        // Additional spawn points for variety
                        new THREE.Vector3(60, 0, 60),
                        new THREE.Vector3(-60, 0, 60),
                        new THREE.Vector3(60, 0, -60),
                        new THREE.Vector3(-60, 0, -60)
                    ];
                    
                    const randomSpawn = spawnPoints[Math.floor(Math.random() * spawnPoints.length)];
                    this.createHumanoidEnemy(randomSpawn);
                    this.lastSpawnTime = now;
                    console.log('Enemy spawned at:', randomSpawn);
                }
            }
            
            updateEnemies(deltaTime) {
                this.enemies.forEach(enemy => {
                    if (!enemy.isAlive) return;
                    
                    const distance = enemy.position.distanceTo(this.player.position);
                    
                    if (distance > 1.5) {
                        // Move towards player
                        const direction = this.player.position.clone().sub(enemy.position).normalize();
                        enemy.position.add(direction.multiplyScalar(enemy.speed * deltaTime));
                        enemy.mesh.position.copy(enemy.position);
                        
                        // Face player
                        enemy.mesh.lookAt(this.player.position);
                        
                        // Walking animation
                        enemy.walkAnimation += deltaTime * 5;
                        const walkBob = Math.sin(enemy.walkAnimation) * 0.1;
                        const legSwing = Math.sin(enemy.walkAnimation) * 0.3;
                        const armSwing = Math.sin(enemy.walkAnimation + Math.PI) * 0.2;
                        
                        // Leg movement
                        enemy.parts.leftLeg.rotation.x = legSwing;
                        enemy.parts.rightLeg.rotation.x = -legSwing;
                        
                        // Arm movement
                        enemy.parts.leftArm.rotation.x = armSwing;
                        enemy.parts.rightArm.rotation.x = -armSwing;
                        
                        // Body bobbing
                        enemy.parts.torso.position.y = 1.2 + walkBob * 0.3;
                        enemy.parts.head.position.y = 2.1 + walkBob * 0.3;
                    } else {
                        // Stop animations
                        enemy.parts.leftLeg.rotation.x = 0;
                        enemy.parts.rightLeg.rotation.x = 0;
                        enemy.parts.leftArm.rotation.x = 0;
                        enemy.parts.rightArm.rotation.x = 0;
                    }
                    
                    // Enemy shooting system - increased frequency for more action
                    if (distance < 25 && distance > 3 && Date.now() - enemy.lastAttackTime > 1800) { // Reduced from 2500 to 1800ms
                        this.enemyShoot(enemy);
                        enemy.lastAttackTime = Date.now();
                        
                        // Shooting animation
                        enemy.parts.rightArm.rotation.x = -Math.PI / 4;
                        setTimeout(() => {
                            if (enemy.parts.rightArm) {
                                enemy.parts.rightArm.rotation.x = 0;
                            }
                        }, 200);
                    }
                    
                    // Melee attack when very close - increased frequency
                    else if (distance < 3 && Date.now() - enemy.lastAttackTime > 1000) { // Reduced from 1500 to 1000ms
                        this.damagePlayer(12); // Increased from 10 to 12 damage
                        enemy.lastAttackTime = Date.now();
                        
                        // Melee attack animation
                        enemy.parts.rightArm.rotation.x = -Math.PI / 2;
                        setTimeout(() => {
                            if (enemy.parts.rightArm) {
                                enemy.parts.rightArm.rotation.x = 0;
                            }
                        }, 400);
                    }
                    
                    // Damage visual effect
                    if (Date.now() - enemy.lastDamageTime < 200) {
                        enemy.parts.torso.material.color.setHex(0xff4444);
                    } else {
                        enemy.parts.torso.material.color.setHex(0x2d2d2d);
                    }
                });
                
                // Clean up dead enemies
                this.enemies = this.enemies.filter(enemy => {
                    if (!enemy.isAlive) {
                        this.scene.remove(enemy.mesh);
                        return false;
                    }
                    return true;
                });
                
                // Check wave completion
                const aliveEnemies = this.enemies.filter(e => e.isAlive).length;
                if (aliveEnemies === 0 && this.enemiesKilledThisWave >= this.enemiesPerWave) {
                    this.nextWave();
                }
            }
            
            nextWave() {
                this.currentWave++;
                this.enemiesKilledThisWave = 0;
                this.enemiesPerWave += 2; // Increase by 2 for more excitement
                this.maxEnemies = Math.min(this.enemiesPerWave, 12); // Higher max enemies for intensity
                
                // Restore player health, ammo and armor
                const oldHealth = this.player.health;
                const oldArmor = this.player.armor;
                this.player.health = Math.min(this.player.maxHealth, this.player.health + 30); // Reduced healing
                this.player.armor = Math.min(this.player.maxArmor, this.player.armor + 25); // Restore some armor
                this.player.totalAmmo += 60;
                
                console.log(`üåä Wave ${this.currentWave} begins! Recovery: +${this.player.health - oldHealth} HP, +${this.player.armor - oldArmor} Armor`);
                console.log(`üí• Intensity increased! Max enemies: ${this.maxEnemies}, Spawn delay: ${this.spawnDelay}ms`);
                
                // Increase enemy difficulty faster for more excitement
                this.spawnDelay = Math.max(800, this.spawnDelay - 150); // Faster reduction, lower minimum
                
                this.updateUI();
            }
            
            shoot() {
                const now = Date.now();
                if (now - this.lastShotTime < this.shotCooldown || this.player.ammo <= 0) return;
                
                console.log('Shooting!');
                this.audio.playShoot(); // Add shooting sound
                
                // Create raycast
                const direction = new THREE.Vector3(0, 0, -1);
                direction.applyQuaternion(this.camera.quaternion);
                
                this.raycaster.set(this.camera.position, direction);
                
                // Detect hits
                const targets = [...this.walls, ...this.enemies.filter(e => e.isAlive).map(e => e.mesh)];
                const intersects = this.raycaster.intersectObjects(targets, true);
                
                if (intersects.length > 0) {
                    const hit = intersects[0];
                    
                    // Check if hit enemy
                    const hitEnemy = this.enemies.find(enemy => {
                        return enemy.mesh === hit.object.parent || enemy.mesh.children.includes(hit.object);
                    });
                    
                    if (hitEnemy && hitEnemy.isAlive) {
                        const damage = 50;
                        hitEnemy.health -= damage;
                        hitEnemy.lastDamageTime = Date.now();
                        this.audio.playHit(); // Add hit sound
                        
                        console.log('Enemy hit!', damage);
                        
                        if (hitEnemy.health <= 0) {
                            hitEnemy.isAlive = false;
                            this.player.kills++;
                            this.enemiesKilledThisWave++;
                            
                            // Small health and armor recovery on kill
                            const oldHealth = this.player.health;
                            const oldArmor = this.player.armor;
                            this.player.health = Math.min(this.player.maxHealth, this.player.health + 15);
                            this.player.armor = Math.min(this.player.maxArmor, this.player.armor + 5);
                            
                            console.log(`‚úÖ Enemy killed! Recovery: +${this.player.health - oldHealth} HP, +${this.player.armor - oldArmor} Armor`);
                            
                            // Death animation
                            hitEnemy.mesh.rotation.z = Math.PI / 2;
                            hitEnemy.mesh.position.y -= 0.5;
                        }
                    }
                }
                
                this.player.ammo--;
                this.lastShotTime = now;
                this.updateUI();
            }
            
            // Bullet System Methods
            createBullet(startPos, targetPos, isPlayer = false) {
                const bulletGeometry = new THREE.SphereGeometry(0.05);
                const bulletMaterial = new THREE.MeshBasicMaterial({ 
                    color: isPlayer ? 0xffff00 : 0xff4444,
                    transparent: true,
                    opacity: 0.9
                });
                const bulletMesh = new THREE.Mesh(bulletGeometry, bulletMaterial);
                bulletMesh.position.copy(startPos);
                
                // Add glow effect
                const glowGeometry = new THREE.SphereGeometry(0.1);
                const glowMaterial = new THREE.MeshBasicMaterial({
                    color: isPlayer ? 0xffff00 : 0xff4444,
                    transparent: true,
                    opacity: 0.3
                });
                const glowMesh = new THREE.Mesh(glowGeometry, glowMaterial);
                glowMesh.position.copy(startPos);
                
                this.scene.add(bulletMesh);
                this.scene.add(glowMesh);
                
                const direction = targetPos.clone().sub(startPos).normalize();
                const speed = 50; // bullets per second
                
                const bullet = {
                    mesh: bulletMesh,
                    glowMesh: glowMesh,
                    position: startPos.clone(),
                    direction: direction,
                    speed: speed,
                    isPlayer: isPlayer,
                    life: 3.0, // 3 seconds max life
                    damage: isPlayer ? 50 : 20 // Increased enemy bullet damage from 15 to 20 for more intensity
                };
                
                if (isPlayer) {
                    this.playerBullets.push(bullet);
                } else {
                    this.enemyBullets.push(bullet);
                }
                
                return bullet;
            }
            
            updateBullets(deltaTime) {
                // Update player bullets
                this.playerBullets = this.playerBullets.filter(bullet => {
                    bullet.position.add(bullet.direction.clone().multiplyScalar(bullet.speed * deltaTime));
                    bullet.mesh.position.copy(bullet.position);
                    bullet.glowMesh.position.copy(bullet.position);
                    bullet.life -= deltaTime;
                    
                    // Check collision with enemies
                    for (let enemy of this.enemies) {
                        if (enemy.isAlive && bullet.position.distanceTo(enemy.position) < 1.5) {
                            enemy.health -= bullet.damage;
                            enemy.lastDamageTime = Date.now();
                            this.audio.playHit();
                            
                            if (enemy.health <= 0) {
                                enemy.isAlive = false;
                                this.player.kills++;
                                this.enemiesKilledThisWave++;
                                
                                // Small health and armor recovery on kill
                                const oldHealth = this.player.health;
                                const oldArmor = this.player.armor;
                                this.player.health = Math.min(this.player.maxHealth, this.player.health + 15);
                                this.player.armor = Math.min(this.player.maxArmor, this.player.armor + 5);
                                
                                console.log(`‚úÖ Enemy killed by bullet! Recovery: +${this.player.health - oldHealth} HP, +${this.player.armor - oldArmor} Armor`);
                                
                                // Death animation
                                enemy.mesh.rotation.z = Math.PI / 2;
                                enemy.mesh.position.y -= 0.5;
                            }
                            
                            // Remove bullet
                            this.scene.remove(bullet.mesh);
                            this.scene.remove(bullet.glowMesh);
                            return false;
                        }
                    }
                    
                    // Check collision with walls
                    const wallHit = this.walls.some(wall => {
                        return bullet.position.distanceTo(wall.position) < 2;
                    });
                    
                    if (wallHit || bullet.life <= 0) {
                        this.scene.remove(bullet.mesh);
                        this.scene.remove(bullet.glowMesh);
                        return false;
                    }
                    
                    return true;
                });
                
                // Update enemy bullets
                this.enemyBullets = this.enemyBullets.filter(bullet => {
                    bullet.position.add(bullet.direction.clone().multiplyScalar(bullet.speed * deltaTime));
                    bullet.mesh.position.copy(bullet.position);
                    bullet.glowMesh.position.copy(bullet.position);
                    bullet.life -= deltaTime;
                    
                    // Check collision with player
                    if (bullet.position.distanceTo(this.player.position) < 1.0) {
                        this.damagePlayer(bullet.damage); // Use damage system with armor
                        console.log('Player hit by bullet! Health:', this.player.health, 'Armor:', this.player.armor);
                        
                        // Remove bullet
                        this.scene.remove(bullet.mesh);
                        this.scene.remove(bullet.glowMesh);
                        return false;
                    }
                    
                    // Check collision with walls
                    const wallHit = this.walls.some(wall => {
                        return bullet.position.distanceTo(wall.position) < 2;
                    });
                    
                    if (wallHit || bullet.life <= 0) {
                        this.scene.remove(bullet.mesh);
                        this.scene.remove(bullet.glowMesh);
                        return false;
                    }
                    
                    return true;
                });
            }
            
            enemyShoot(enemy) {
                // Calculate shooting position (from enemy's weapon)
                const shootPos = enemy.position.clone();
                shootPos.y += 1.5; // Shoot from chest level
                shootPos.add(new THREE.Vector3(0.4, 0, 0.2)); // Offset for weapon position
                
                // Add some inaccuracy to enemy shots - reduced for more threat
                const targetPos = this.player.position.clone();
                const inaccuracy = 1.2; // Reduced from 2.0 to 1.2 for better accuracy
                targetPos.add(new THREE.Vector3(
                    (Math.random() - 0.5) * inaccuracy,
                    (Math.random() - 0.5) * inaccuracy * 0.5,
                    (Math.random() - 0.5) * inaccuracy
                ));
                
                this.createBullet(shootPos, targetPos, false);
                this.audio.playEnemyShoot();
                
                console.log('Enemy fired bullet at player!');
            }
            
            reload() {
                if (this.player.totalAmmo > 0 && this.player.ammo < this.player.maxAmmo) {
                    const needed = this.player.maxAmmo - this.player.ammo;
                    const available = Math.min(needed, this.player.totalAmmo);
                    this.player.ammo += available;
                    this.player.totalAmmo -= available;
                    this.updateUI();
                    
                    // Reload sound effect
                    if (this.audio.audioContext) {
                        const oscillator = this.audio.audioContext.createOscillator();
                        const gainNode = this.audio.audioContext.createGain();
                        
                        oscillator.type = 'square';
                        oscillator.frequency.setValueAtTime(400, this.audio.audioContext.currentTime);
                        oscillator.frequency.setValueAtTime(300, this.audio.audioContext.currentTime + 0.1);
                        oscillator.frequency.setValueAtTime(350, this.audio.audioContext.currentTime + 0.3);
                        
                        gainNode.gain.setValueAtTime(0.2, this.audio.audioContext.currentTime);
                        gainNode.gain.setValueAtTime(0, this.audio.audioContext.currentTime + 0.5);
                        
                        oscillator.connect(gainNode);
                        gainNode.connect(this.audio.audioContext.destination);
                        
                        oscillator.start();
                        oscillator.stop(this.audio.audioContext.currentTime + 0.5);
                    }
                    
                    console.log('üîÑ Reloading...');
                }
            }
            
            
            canMoveTo(position) {
                // Check map boundaries - expanded for larger map (¬±95 to stay within ¬±100 walls)
                if (Math.abs(position.x) > 95 || Math.abs(position.z) > 95) {
                    console.log(`üö´ Boundary collision at (${position.x.toFixed(1)}, ${position.z.toFixed(1)})`);
                    return false;
                }
                
                // Player collision radius
                const playerRadius = 1.0;
                
                // Check collision with all walls/obstacles/buildings
                for (let wall of this.walls) {
                    if (this.checkBoxCollision(position, playerRadius, wall)) {
                        console.log(`üö´ Object collision at (${position.x.toFixed(1)}, ${position.z.toFixed(1)})`);
                        return false;
                    }
                }
                
                return true;
            }
            
            checkBoxCollision(playerPos, playerRadius, boxMesh) {
                // Get box bounds
                const box = new THREE.Box3().setFromObject(boxMesh);
                
                // Expand box by player radius
                box.expandByScalar(playerRadius);
                
                // Check if player position is inside expanded box
                return box.containsPoint(playerPos);
            }

            updateMovement(deltaTime) {
                const moveSpeed = this.player.speed * deltaTime;
                const direction = new THREE.Vector3();
                
                if (this.keys['KeyW']) direction.z -= 1;
                if (this.keys['KeyS']) direction.z += 1;
                if (this.keys['KeyA']) direction.x -= 1;
                if (this.keys['KeyD']) direction.x += 1;
                
                if (direction.length() > 0) {
                    direction.normalize();
                    direction.applyQuaternion(this.camera.quaternion);
                    direction.y = 0; // Keep horizontal movement
                    
                    const newPosition = this.player.position.clone().add(direction.multiplyScalar(moveSpeed));
                    
                    // Enhanced collision detection
                    if (this.canMoveTo(newPosition)) {
                        this.player.position.copy(newPosition);
                    }
                }
                
                // Update camera position and rotation
                this.camera.position.copy(this.player.position);
                this.camera.rotation.order = 'YXZ';
                this.camera.rotation.y = this.player.rotation.y;
                this.camera.rotation.x = this.player.rotation.x;
            }
            
            updateUI() {
                // Ensure all player stats are non-negative
                this.player.health = Math.max(0, this.player.health);
                this.player.armor = Math.max(0, this.player.armor);
                
                document.getElementById('healthText').textContent = Math.max(0, this.player.health);
                document.getElementById('healthBar').style.width = Math.max(0, (this.player.health / this.player.maxHealth) * 100) + '%';
                
                document.getElementById('armorText').textContent = Math.max(0, this.player.armor);
                document.getElementById('armorBar').style.width = Math.max(0, (this.player.armor / this.player.maxArmor) * 100) + '%';
                
                document.getElementById('ammoText').textContent = `${this.player.ammo}/${this.player.totalAmmo}`;
                document.getElementById('ammoBar').style.width = (this.player.ammo / this.player.maxAmmo) * 100 + '%';
                
                document.getElementById('killsText').textContent = this.player.kills;
                document.getElementById('waveText').textContent = this.currentWave;
                
                // Update time display
                if (this.startTime) {
                    const elapsedSeconds = Math.floor((Date.now() - this.startTime) / 1000);
                    const minutes = Math.floor(elapsedSeconds / 60);
                    const seconds = elapsedSeconds % 60;
                    document.getElementById('timeText').textContent = `${minutes}:${seconds.toString().padStart(2, '0')}`;
                }
                
                // Update position display
                const x = Math.round(this.player.position.x);
                const z = Math.round(this.player.position.z);
                document.getElementById('positionText').textContent = `(${x}, ${z})`;
                
                // Update bullet count
                document.getElementById('bulletCount').textContent = this.enemyBullets ? this.enemyBullets.length : 0;
            }
            
            showDamageEffect() {
                const overlay = document.getElementById('damageOverlay');
                overlay.style.opacity = '0.8';
                setTimeout(() => {
                    overlay.style.opacity = '0';
                }, 300);
            }
            
            // Damage system that uses armor first
            damagePlayer(damage) {
                let remainingDamage = damage;
                let armorDamage = 0;
                let healthDamage = 0;
                
                // First, damage armor
                if (this.player.armor > 0) {
                    armorDamage = Math.min(this.player.armor, remainingDamage);
                    this.player.armor -= armorDamage;
                    remainingDamage -= armorDamage;
                }
                
                // Then damage health with remaining damage
                if (remainingDamage > 0) {
                    healthDamage = remainingDamage;
                    this.player.health -= remainingDamage;
                }
                
                console.log(`üí• Damage dealt: ${damage} | Armor: -${armorDamage} (${this.player.armor}/${this.player.maxArmor}) | Health: -${healthDamage} (${this.player.health}/${this.player.maxHealth})`);
                
                this.showDamageEffect();
                this.audio.playPlayerHurt();
            }
            
            // Health regeneration system
            handleHealthRegeneration() {
                const now = Date.now();
                
                // Health regeneration (every 8 seconds)
                if (now - this.player.lastHealthRegen > this.player.healthRegenRate) {
                    if (this.player.health < this.player.maxHealth) {
                        this.player.health = Math.min(this.player.maxHealth, this.player.health + 15);
                        this.player.lastHealthRegen = now;
                        console.log('Health regenerated! Current health:', this.player.health);
                    }
                }
                
                // Armor regeneration (every 12 seconds, using separate timer)
                if (now - this.player.lastArmorRegen > 12000) {
                    if (this.player.armor < this.player.maxArmor) {
                        this.player.armor = Math.min(this.player.maxArmor, this.player.armor + 10);
                        this.player.lastArmorRegen = now;
                        console.log('Armor regenerated! Current armor:', this.player.armor);
                    }
                }
            }
            
            // Health pack system
            spawnHealthPacks() {
                const now = Date.now();
                
                // Spawn health pack every 20 seconds
                if (now - this.lastHealthPackSpawn > this.healthPackSpawnRate && this.healthPacks.length < 2) {
                    this.createHealthPack();
                    this.lastHealthPackSpawn = now;
                }
            }
            
            createHealthPack() {
                // Create health pack geometry
                const geometry = new THREE.BoxGeometry(0.5, 0.3, 0.5);
                const material = new THREE.MeshLambertMaterial({ color: 0x00ff00 });
                const mesh = new THREE.Mesh(geometry, material);
                
                // Random position on the expanded map (¬±80 range instead of ¬±20)
                const x = (Math.random() - 0.5) * 160;
                const z = (Math.random() - 0.5) * 160;
                mesh.position.set(x, 0.5, z);
                
                // Add glow effect
                const glowGeometry = new THREE.BoxGeometry(0.7, 0.5, 0.7);
                const glowMaterial = new THREE.MeshBasicMaterial({ 
                    color: 0x00ff00, 
                    transparent: true, 
                    opacity: 0.3 
                });
                const glowMesh = new THREE.Mesh(glowGeometry, glowMaterial);
                glowMesh.position.copy(mesh.position);
                
                this.scene.add(mesh);
                this.scene.add(glowMesh);
                
                const healthPack = {
                    mesh: mesh,
                    glowMesh: glowMesh,
                    position: mesh.position,
                    rotation: 0,
                    healAmount: 50
                };
                
                this.healthPacks.push(healthPack);
                console.log('Health pack spawned at:', mesh.position);
            }
            
            updateHealthPacks() {
                this.healthPacks.forEach((pack, index) => {
                    // Rotate the health pack
                    pack.rotation += 0.02;
                    pack.mesh.rotation.y = pack.rotation;
                    pack.glowMesh.rotation.y = pack.rotation;
                    
                    // Float up and down
                    pack.mesh.position.y = 0.5 + Math.sin(pack.rotation * 2) * 0.1;
                    pack.glowMesh.position.copy(pack.mesh.position);
                    
                    // Check collision with player
                    if (pack.position.distanceTo(this.player.position) < 2.0) {
                        // Heal player
                        const oldHealth = this.player.health;
                        const oldArmor = this.player.armor;
                        this.player.health = Math.min(this.player.maxHealth, this.player.health + pack.healAmount);
                        this.player.armor = Math.min(this.player.maxArmor, this.player.armor + 25);
                        
                        console.log(`üè• Health pack collected! Recovery: +${this.player.health - oldHealth} HP, +${this.player.armor - oldArmor} Armor`);
                        
                        // Remove health pack
                        this.scene.remove(pack.mesh);
                        this.scene.remove(pack.glowMesh);
                        this.healthPacks.splice(index, 1);
                        
                        // Play sound effect if available
                        if (this.audio && this.audio.playHeal) {
                            this.audio.playHeal();
                        }
                    }
                });
            }
            
            togglePause() {
                // Only allow pause/unpause when game is running
                if (!this.isRunning && !this.isPaused) {
                    console.log('‚ö†Ô∏è Cannot pause: Game not running');
                    return;
                }
                
                this.isPaused = !this.isPaused;
                const pauseMenu = document.getElementById('pauseMenu');
                
                if (this.isPaused) {
                    // Show pause menu
                    pauseMenu.style.display = 'flex';
                    
                    // Update pause menu stats
                    document.getElementById('pauseWave').textContent = this.currentWave;
                    document.getElementById('pauseKills').textContent = this.player.kills;
                    document.getElementById('pauseHealth').textContent = Math.max(0, this.player.health);
                    document.getElementById('pauseArmor').textContent = Math.max(0, this.player.armor);
                    
                    // Update time display
                    if (this.startTime) {
                        const elapsedSeconds = Math.floor((Date.now() - this.startTime) / 1000);
                        const minutes = Math.floor(elapsedSeconds / 60);
                        const seconds = elapsedSeconds % 60;
                        document.getElementById('pauseTime').textContent = `${minutes}:${seconds.toString().padStart(2, '0')}`;
                    }
                    
                    // Release pointer lock
                    if (document.pointerLockElement) {
                        document.exitPointerLock();
                        console.log('üîì Pointer lock released');
                    }
                    
                    console.log('‚è∏Ô∏è Game Paused - Tab switching safe');
                } else {
                    // Hide pause menu
                    pauseMenu.style.display = 'none';
                    
                    // Re-lock pointer - always try when unpausing
                    if (this.isRunning) {
                        try {
                            document.body.requestPointerLock().then(() => {
                                console.log('üîí Pointer lock re-acquired successfully');
                            }).catch((error) => {
                                console.warn('‚ö†Ô∏è Failed to re-acquire pointer lock:', error);
                                // Try again after a short delay
                                setTimeout(() => {
                                    document.body.requestPointerLock();
                                }, 100);
                            });
                        } catch (error) {
                            console.warn('‚ö†Ô∏è Pointer lock request failed:', error);
                        }
                    }
                    
                    console.log('‚ñ∂Ô∏è Game Resumed');
                }
            }
            
            start() {
                try {
                    console.log('üéÆ Starting game...');
                    
                    document.getElementById('loadingScreen').style.display = 'none';
                    document.getElementById('gameCanvas').style.display = 'block';
                    document.getElementById('gameUI').style.display = 'block';
                    
                    // Initialize audio (require user interaction)
                    if (this.audio.audioContext && this.audio.audioContext.state === 'suspended') {
                        this.audio.audioContext.resume().then(() => {
                            console.log('üéµ Audio system activated');
                        }).catch(err => {
                            console.warn('Audio activation failed:', err);
                        });
                    }
                    
                    // Lock mouse pointer
                    try {
                        document.body.requestPointerLock().then(() => {
                            console.log('üîí Initial pointer lock acquired successfully');
                        }).catch((error) => {
                            console.warn('‚ö†Ô∏è Failed to acquire initial pointer lock:', error);
                            // Show a user-friendly message
                            alert('ËØ∑ÁÇπÂáªÊ∏∏ÊàèÂå∫Âüü‰ª•ÂêØÁî®Èº†Ê†áÊéßÂà∂ (Click on the game area to enable mouse control)');
                        });
                    } catch (error) {
                        console.warn('‚ö†Ô∏è Pointer lock not supported or failed:', error);
                    }
                    
                    this.isRunning = true;
                    this.startTime = Date.now(); // Record start time
                    
                    // Reset regeneration timers
                    this.player.lastHealthRegen = Date.now();
                    this.player.lastArmorRegen = Date.now();
                    
                    console.log('üõ°Ô∏è Player initialized: Health ${this.player.health}/${this.player.maxHealth}, Armor ${this.player.armor}/${this.player.maxArmor}');
                    console.log('üó∫Ô∏è Map expanded! Playable area: 200√ó200 units (¬±95 movement range)');
                    console.log('üè¢ Enhanced with 20 buildings and 32 cover objects for tactical gameplay');
                    
                    this.updateUI();
                    
                    console.log('üöÄ Starting game loop...');
                    this.gameLoop();
                    
                    console.log('‚úÖ Enhanced Tactical Shooter Started!');
                } catch (error) {
                    console.error('Failed to start game:', error);
                }
            }
            
            gameLoop() {
                if (!this.isRunning) return;
                
                try {
                    const deltaTime = this.clock.getDelta();
                    
                    if (!this.isPaused) {
                        this.updateMovement(deltaTime);
                        this.spawnEnemies();
                        this.updateEnemies(deltaTime);
                        this.updateBullets(deltaTime); // Add bullet updates
                        this.spawnHealthPacks(); // Add health pack spawning
                        this.updateHealthPacks(); // Add health pack updates
                        this.handleHealthRegeneration(); // Add health regeneration
                        this.updateUI(); // Update UI to show bullet count
                        
                        // Check game over
                        if (this.player.health <= 0) {
                            this.gameOver();
                            return;
                        }
                    }
                    
                    this.renderer.render(this.scene, this.camera);
                } catch (error) {
                    console.error('Game loop error:', error);
                }
                
                requestAnimationFrame(() => this.gameLoop());
            }
            
            gameOver() {
                this.isRunning = false;
                const finalScore = this.player.kills * 100 + this.currentWave * 500;
                const playTime = this.startTime ? Math.floor((Date.now() - this.startTime) / 1000) : 0;
                const minutes = Math.floor(playTime / 60);
                const seconds = playTime % 60;
                
                alert(`üéÆ GAME OVER!\n\nFinal Stats:\nKills: ${this.player.kills}\nWaves Survived: ${this.currentWave}\nPlay Time: ${minutes}:${seconds.toString().padStart(2, '0')}\nFinal Health: ${this.player.health}/${this.player.maxHealth}\nFinal Armor: ${this.player.armor}/${this.player.maxArmor}\nFinal Score: ${finalScore}`);
                location.reload();
            }
        }
        
        // Start the game with error handling
        console.log('üéÆ Initializing Enhanced Tactical Shooter...');
        try {
            const game = new EnhancedTacticalShooter();
            console.log('‚úÖ Game object created successfully');
            
            window.game = game; // For debugging
            
        } catch (error) {
            console.error('‚ùå Failed to initialize game:', error);
            alert('Failed to initialize game. Please refresh the page.');
        }
    </script>
</body>
</html>